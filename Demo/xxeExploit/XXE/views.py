from django.shortcuts import render, HttpResponse, redirect, get_object_or_404
from .models import ToDoItem, RegexRule, BlockedIP, WhitelistedIP, AppConfig
from django.http import HttpResponseBadRequest, HttpResponseForbidden, JsonResponse
from django.views.decorators.csrf import csrf_exempt
import re
import logging
import colorlog
from lxml import etree
from django.utils.functional import lazy

# Fetch RESOLVE_ENTITIES dynamically from the database
def get_resolve_entities():
    try:
        config = AppConfig.objects.get(key="RESOLVE_ENTITIES")
        return config.value.lower() == "true"
    except AppConfig.DoesNotExist:
        # Default to True if not set
        return True

# Use lazy evaluation for RESOLVE_ENTITIES
RESOLVE_ENTITIES = lazy(get_resolve_entities, bool)()

def home(request):
    return render(request, "home.html")

@csrf_exempt
def todos(request):
    items = ToDoItem.objects.all()
    return render(request, "todo.html", {"todo": items})

@csrf_exempt
def secret(request):
    return HttpResponse("This is Secret Page")

@csrf_exempt
def get_client_ip(request):
    x_forwarded_for = request.META.get('HTTP_X_FORWARDED_FOR')
    if x_forwarded_for:
        ip = x_forwarded_for.split(',')[0]
    else:
        ip = request.META.get('REMOTE_ADDR')
    return ip

@csrf_exempt
def ip_whitelisting(request):
    if request.method == 'POST':
        if 'add' in request.POST:
            name = request.POST.get('name')
            ip_address = request.POST.get('ip_address')
            if name and ip_address:
                WhitelistedIP.objects.create(name=name, ip_address=ip_address)
                return redirect('ip_whitelisting')
                # return redirect('validation_page')
        elif 'delete' in request.POST:
            ip_id = request.POST.get('ip_id')
            if ip_id:
                ip = get_object_or_404(WhitelistedIP, id=ip_id)
                ip.delete()
                return redirect('ip_whitelisting')
                # return redirect('validation_page')
    
    whitelisted_ips = WhitelistedIP.objects.all().order_by('-created_at')
    return render(request, "ip_whitelisting.html", {"whitelisted_ips": whitelisted_ips})
    # return render(request, "dashboard.html", {"whitelisted_ips": whitelisted_ips})

handler = colorlog.StreamHandler()
handler.setFormatter(colorlog.ColoredFormatter(
    "%(log_color)s%(asctime)s - %(levelname)s - %(message)s",
    log_colors={
        'DEBUG': 'cyan',
        'INFO': 'green',
        'WARNING': 'yellow',
        'ERROR': 'red',
        'CRITICAL': 'bold_red',
    }
))
logger = logging.getLogger(__name__)
logger.setLevel(logging.DEBUG)
logger.addHandler(handler) 
# logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

@csrf_exempt
def save_todo(request):
    client_ip = get_client_ip(request)
    if not WhitelistedIP.objects.filter(ip_address=client_ip).exists():
        return render(request, "blocked_users.html", {'client_ip': client_ip})
    if request.method == "POST":
        try:
            xml_data = request.body
            xml_string = xml_data.decode("utf-8")
            try:
                parser = etree.XMLParser(resolve_entities=False, no_network=True)
                root = etree.fromstring(xml_data, parser)
            except etree.XMLSyntaxError as e:
                logger.warning(f"XML Syntax Error: {str(e)}")
            blocked_regex_list = list(RegexRule.objects.filter(is_allowed=False).values_list('regex', flat=True))
            for pattern in blocked_regex_list:
                compiled_pattern = re.compile(pattern)
                if compiled_pattern.search(xml_string):
                    BlockedIP.objects.get_or_create(ip_address=client_ip)
                    logger.warning(f"Blocked IP: {client_ip} for pattern: {pattern}")
                    return render(request, 'notallowed.html')
            parser = etree.XMLParser(
                resolve_entities=RESOLVE_ENTITIES, 
                no_network=not RESOLVE_ENTITIES, 
                load_dtd=RESOLVE_ENTITIES)
            root = etree.fromstring(xml_data, parser)
            if RESOLVE_ENTITIES:
                response = HttpResponse(f"{etree.tostring(root, pretty_print=True).decode()}")
            else:
                response = HttpResponse(f"{etree.tostring(root, pretty_print=True).decode()}")
            title_element = root.find(".//title")
            status_element = root.find(".//status")
            if title_element is not None and status_element is not None:
                title = title_element.text.strip() if title_element.text else ""
                status = status_element.text.strip().lower() == "true"
                ToDoItem.objects.create(title=title, completed=status)
                return HttpResponse(f"ToDo item saved: Title = {title}, Completed = {status}")
        except Exception as e:
            logger.error(f"Error processing XML: {str(e)}")
            return HttpResponseBadRequest(f"Error: {str(e)}")
        return HttpResponse(response)

    else:
        return HttpResponseBadRequest("Invalid request")
    
@csrf_exempt
def validation_page(request):
    regex_rules = RegexRule.objects.all()
    resolve_entities = get_resolve_entities()  # Fetch the current value dynamically
    return render(request, "dashboard.html", {
        "regex_rules": regex_rules,
        "resolve_entities": resolve_entities,
        "whitelisted_ips": WhitelistedIP.objects.all().order_by('-created_at'),
    })

@csrf_exempt
def save_validation(request):
    if request.method == 'POST':
        name = request.POST.get('name')
        regex = request.POST.get('regex')
        is_allowed = request.POST.get('is_allowed') == 'True'
        
        if not name or not regex:
            return HttpResponseBadRequest("Name and Regex fields are required.")
        
        RegexRule.objects.create(name=name, regex=regex, is_allowed=is_allowed)
        return redirect('Validation Page')
    return HttpResponseBadRequest("Invalid request")

def edit_validation(request, id):
    regex_rule = get_object_or_404(RegexRule, id=id)
    if request.method == 'POST':
        regex_rule.name = request.POST.get('name')
        regex_rule.regex = request.POST.get('regex')
        regex_rule.is_allowed = request.POST.get('is_allowed') == 'True'
        regex_rule.save()
        return redirect('Validation Page')
    return render(request, 'edit_validation.html', {'regex_rule': regex_rule})

def delete_validation(request, id):
    regex_rule = get_object_or_404(RegexRule, id=id)
    if request.method == 'POST':
        regex_rule.delete()
        return redirect('Validation Page')
    return render(request, 'delete_validation.html', {'regex_rule': regex_rule})

@csrf_exempt
def update_resolve_entities(request):
    if request.method == "POST":
        try:
            new_value = request.POST.get("resolve_entities")
            if new_value is not None:
                config, created = AppConfig.objects.get_or_create(key="RESOLVE_ENTITIES")
                config.value = "True" if new_value.lower() == "true" else "False"
                config.save()
                return JsonResponse({"success": True, "message": "RESOLVE_ENTITIES updated successfully."})
            else:
                return JsonResponse({"success": False, "message": "Missing 'resolve_entities' parameter."}, status=400)
        except Exception as e:
            # Log the error for debugging
            print(f"Error in update_resolve_entities: {str(e)}")
            return JsonResponse({"success": False, "message": f"Server error: {str(e)}"}, status=500)
    return JsonResponse({"success": False, "message": "Invalid request method."}, status=405)

